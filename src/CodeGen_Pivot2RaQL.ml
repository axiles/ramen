(* Transpilation of pivot operations into RaQL *)
open Batteries
open Stdint

open RamenLog
open RamenHelpersNoLog
module DT = DessserTypes
module N = RamenName
module O = RamenOperation
module T = RamenTypes
module P = Pivot.DessserGen
module VSI = RamenSync.Value.SourceInfo

let generate get_program src_file p =
  let parent_func =
    let pn, fn = N.fq_parse p.P.from in
    match get_program pn with
    | exception Not_found ->
        Printf.sprintf "Program %s does not exist"
          (pn :> string) |>
        failwith
    | prog ->
        (try List.find (fun f -> f.VSI.name = fn) prog.VSI.funcs
        with Not_found ->
          Printf.sprintf "No function %s in program %s"
            (fn :> string)
            (pn :> string) |>
          failwith) in
  let parent_out =
    O.out_type_of_operation ~with_priv:false parent_func.VSI.operation in
  let type_of_column column =
    let t = List.find (fun ft -> ft.RamenTuple.name = column) parent_out in
    t.RamenTuple.typ in
  File.with_file_out ~mode:[`create; `text ; `trunc]
                     (src_file : N.path :> string) (fun oc ->
    Printf.fprintf oc
      "-- Pivot operation automatically generated by ramen %s at %s\n\n"
      RamenVersions.release_tag (string_of_time (Unix.time ())) ;
    Printf.fprintf oc "DEFINE pivot AS\n" ;
    Printf.fprintf oc "  FROM %s\n" (ramen_quote (p.P.from :> string)) ;
    Printf.fprintf oc "  WHERE %a\n"
      (CodeGen_SimpleFilter2RaQL.print type_of_column) p.where ;
    Printf.fprintf oc "  SELECT\n" ;
    Printf.fprintf oc "    TRUNCATE(start, %f) AS start,\n" p.duration ;
    Array.iter (fun field ->
      Printf.fprintf oc "    %s,\n" (ramen_quote (field : N.field :> string))
    ) p.group_by ;
    Array.iter (fun field ->
      (* Default to select a type named as the output field name: *)
      let types =
        if array_is_empty field.P.types then [| (field.name :> string) |]
        else field.types in
      (* Prepare a private field with the value (or NULL) for that field: *)
      Printf.fprintf oc "    (IF %a THEN %s) AS _%a,\n"
        (Array.print ~first:"" ~last:"" ~sep:" OR "
          (fun oc selector ->
            Printf.fprintf oc "%s LIKE %S"
              (ramen_quote (p.type_field :> string)) selector))
          types
        (ramen_quote (p.value_field :> string))
        N.field_print field.name ;
      let num_aggrs =
        Bool.to_int field.count +
        Bool.to_int field.first +
        Bool.to_int field.last +
        Bool.to_int field.min +
        Bool.to_int field.max +
        Bool.to_int field.sum +
        Bool.to_int field.avg +
        Bool.to_int (Array.length field.percentiles > 0) +
        Bool.to_int (Array.length field.tops > 0) in
      let single_aggr = num_aggrs = 1 in
      let alias_of aggr_name oc =
        if single_aggr then
          N.field_print oc field.name
        else
          Printf.fprintf oc "%s_%a" aggr_name N.field_print field.name in
      let simple_aggr oc op_name =
        Printf.fprintf oc "    %s(_%a) AS %t,\n"
          op_name
          N.field_print field.name
          (alias_of (String.lowercase op_name))
      in
      if field.count then simple_aggr oc "COUNT" ;
      if field.first then simple_aggr oc "FIRST" ;
      if field.last then simple_aggr oc "LAST" ;
      if field.min then simple_aggr oc "MIN" ;
      if field.max then simple_aggr oc "MAX" ;
      if field.sum then simple_aggr oc "SUM" ;
      if field.avg then simple_aggr oc "AVG" ;
      if not (array_is_empty field.percentiles) then
        Printf.fprintf oc "    %a PERCENTILE(_%a) AS %t,\n"
          (fun oc -> function
            | [| p |] ->
                Float.print oc p
            | ps ->
                Array.print ~first:"[" ~last:"]" Float.print oc ps)
            field.percentiles
          N.field_print field.name
          (alias_of (String.lowercase "perc")) ;
      Array.iter (function
        | P.{ n ; by = None } ->
            Printf.fprintf oc "    LIST TOP %s (_%a) AS %t,\n"
              (Uint16.to_string n)
              N.field_print field.name
              (alias_of "top")
        | { n ; by = Some b }->
            Printf.fprintf oc "    LIST TOP %s (_%a) BY %a AS %t,\n"
              (Uint16.to_string n)
              N.field_print field.name
              N.field_print b
              (alias_of "top")
      ) field.tops
    ) p.fields ;
    (* Stay clear from the last delimiter: *)
    Printf.fprintf oc "    true AS _delim\n" ;
    let group_by =
      Enum.append
        (Array.enum p.group_by /@ (fun s -> (s :> string)))
        (Enum.singleton (Printf.sprintf "TRUNCATE(start, %f)" p.duration)) in
    Printf.fprintf oc "  GROUP BY %a\n"
      (Enum.print ~first:"" ~last:"" ~sep:", " String.print) group_by ;
    Printf.fprintf oc "  COMMIT AFTER in.start > out.start + %a;"
      print_nice_float (p.duration +. p.max_lateness))
