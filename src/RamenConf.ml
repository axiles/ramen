(* The configuration that's managed by this module includes:
 *
 * - the Running Configuration (RC), which is the set of all programs that are
 *   supposed to run;
 * - the per worker Stats (generated by the archivist with option --stats)
 *   and used for allocating storage space;
 * - the per worker storage allocations (also generated by the archivist with
 *   option --allocs)
 * - the transient ongoing replays.
 *
 * All these bits of configuration have in common that they must be available
 * at every sites at least read-only (also write where the corresponding
 * commands are issued).
 *)
open Batteries
open RamenLog
open RamenHelpers
open RamenConsts
module O = RamenOperation
module N = RamenName
module E = RamenExpr
module T = RamenTypes
module Files = RamenFiles
module Retention = RamenRetention
module TimeRange = RamenTimeRange
module Versions = RamenVersions
module Globals = RamenGlobalVariables
module ZMQClient = RamenSyncZMQClient

(*
 * Ramen internal configuration record
 *
 * Just a handy bag of global parameters.
 *)

type conf =
  { log_level : log_level ;
    persist_dir : N.path ;
    test : bool ; (* true within `ramen test` *)
    keep_temp_files : bool ;
    reuse_prev_files : bool ;
    initial_export_duration : float ;
    site : N.site (* this site name *) ;
    masters : N.site Set.t ;
    bundle_dir : N.path ;
    sync_url : string ;
    username : string ;
    (* The keys not the file names: *)
    srv_pub_key : string ;
    clt_pub_key : string ;
    clt_priv_key : string }

type identity_file =
  { username : string ;
    server_public_key : string ;
    client_public_key : string ;
    client_private_key : string }
  [@@ppp PPP_JSON]

let make_conf
      ?(debug=false) ?(quiet=false)
      ?(keep_temp_files=false) ?(reuse_prev_files=false)
      ?(forced_variants=[])
      ?(initial_export_duration=Default.initial_export_duration)
      ~site ?(test=false)
      ?(bundle_dir=RamenCompilConfig.default_bundle_dir)
      ?(masters=Set.empty)
      ?(sync_url="")
      ?(username="")
      ?(srv_pub_key="")
      ?(clt_pub_key="")
      ?(clt_priv_key="")
      ?(identity=N.path "")
      persist_dir =
  if debug && quiet then
    failwith "Options --debug and --quiet are incompatible." ;
  let log_level =
    if debug then Debug else if quiet then Quiet else Normal in
  let persist_dir = N.simplified_path persist_dir in
  (* Read values from the file and et unset parameters with those.
   * In effect, the CLI parameters overwrite the file content. *)
  let username, srv_pub_key, clt_pub_key, clt_priv_key =
    if N.is_empty identity || not (Files.exists identity) then
      username, srv_pub_key, clt_pub_key, clt_priv_key
    else
      let what = Printf.sprintf2 "Reading identity file %a"
                   N.path_print identity in
      log_exceptions ~what (fun () ->
        let id = Files.ppp_of_file identity_file_ppp_json identity in
        (if username <> "" then username else id.username),
        (if srv_pub_key <> "" then srv_pub_key else id.server_public_key),
        (if clt_pub_key <> "" then clt_pub_key else id.client_public_key),
        (if clt_priv_key <> "" then clt_priv_key else id.client_private_key))
  in
  RamenExperiments.set_variants persist_dir forced_variants ;
  { log_level ; persist_dir ; keep_temp_files ; reuse_prev_files ;
    initial_export_duration ; site ; test ; bundle_dir ; masters ;
    sync_url ; username ; srv_pub_key ; clt_pub_key ; clt_priv_key }

(*
 * Common comprehensive representation of functions and programs
 *
 * This configuration (or the simpler, more compact and less redundant
 * serialized variant) is embedded directly in the workers binary.
 *)

(*
module Func =
struct
  type parent =
    O.site_identifier * N.rel_program option * N.func

  type t =
    { program_name : N.program ;
      name : N.func ;
      (* A function which history we might want to query in the future
       * so make sure it is either stored or can be computed again from
       * ancestor stored history: *)
      retention : Retention.t option ;
      doc : string ;
      (* A lazy function runs only if it is used: has a children that is
       * itself used, emits notifications or export its data somehow. *)
      is_lazy : bool ;
      mutable operation : O.t ;
      in_type : RamenFieldMaskLib.in_type ;
      (* The signature identifies the code but not the actual parameters.
       * Those signatures are used to distinguish sets of ringbufs
       * or any other files where tuples are stored, so that those files
       * change when the code change, without a need to also change the
       * name of the operation. *)
      mutable signature : string ;
      parents : parent list }

  let serialized (t : t) =
    Value.SourceInfo.{
      name = t.name ;
      retention = t.retention ;
      is_lazy = t.is_lazy ;
      doc = t.doc ;
      operation = t.operation ;
      out_record = O.out_record_of_operation ~with_private:false t.operation ;
      factors = O.factors_of_operation t.operation ;
      signature = t.signature }

  let unserialized program_name (t : Value.SourceInfo.compiled_func) =
    { program_name ;
      name = t.name ;
      retention = t.retention ;
      is_lazy = t.is_lazy ;
      doc = t.doc ;
      operation = t.operation ;
      signature = t.signature ;
      in_type = RamenFieldMaskLib.in_type_of_operation t.operation ;
      parents = O.parents_of_operation t.operation }

  (* TODO: takes a func instead of child_prog? *)
  let program_of_parent_prog child_prog = function
    | None -> child_prog
    | Some rel_prog ->
        N.(program_of_rel_program child_prog rel_prog)

  let print_parent oc (parent : parent) =
    match parent with
    | site, None, f ->
        Printf.fprintf oc "%a%s"
          O.print_site_identifier site
          (f :> string)
    | site, Some p, f ->
        Printf.fprintf oc "%a%s/%s"
          O.print_site_identifier site
          (p :> string) (f :> string)

  (* Only for debug or keys, not for paths! *)
  let fq_name f = N.fq_of_program f.program_name f.name

  let path f =
    N.path_cat
      (* Per function paths are used to store worker states etc so must
       * depends on the actual program suffix: *)
      [ N.path_of_program ~suffix:true f.program_name ;
        N.path (f.name :> string) ]

  let signature func params =
    (* We'd like to be formatting independent so that operation text can be
     * reformatted without ramen recompiling it. For this it is not OK to
     * strip redundant white spaces as some of those might be part of literal
     * string values. So we print it, trusting the printer to be exhaustive.
     * This is not enough to print the expression with types, as those do not
     * contain relevant info such as field rank. We therefore print without
     * types and encode input/output types explicitly below.
     * Also, notice that the program-wide running condition does not alter
     * the function signature, and rightfully so, as a change in the running
     * condition does not imply we should disregard past data or consider the
     * function changed in any way. It's `ramen run` job to evaluate the
     * running condition independently. *)
    let op_str = IO.to_string (O.print false) func.operation
    and out_type =
      O.out_type_of_operation ~with_private:false func.operation in
    "OP="^ op_str ^
    ";IN="^ RamenFieldMaskLib.in_type_signature func.in_type ^
    ";OUT="^ RamenTuple.type_signature out_type ^
    (* Similarly to input type, also depends on the parameters type: *)
    ";PRM="^ RamenTuple.params_type_signature params |>
    N.md5

  let dump_io func =
    !logger.debug "func %S:\n\tinput type: %a\n\toutput type: %a"
      (func.name :> string)
      RamenFieldMaskLib.print_in_type func.in_type
      RamenTuple.print_typ
        (O.out_type_of_operation ~with_private:false func.operation)

  let make_fieldmask parent child =
    let out_typ =
      O.out_type_of_operation ~with_private:false parent.operation in
    RamenFieldMaskLib.fieldmask_of_operation ~out_typ child.operation
end

module Program =
struct
  type t =
    { default_params : RamenTuple.params ;
      condition : E.t ; (* for debug only *)
      globals : Globals.t list ;
      funcs : Func.t list }

  let serialized (t : t) =
    Value.SourceInfo.{
      default_params = t.default_params ;
      condition = t.condition ;
      globals = t.globals ;
      funcs = List.map Func.serialized t.funcs }

  let unserialized program_name (t : Value.SourceInfo.compiled_program) =
    { default_params = t.default_params ;
      condition = t.condition ;
      globals = t.globals ;
      funcs = List.map (Func.unserialized program_name) t.funcs }

  (* The site is not taken from the conf because choreographer might want
   * to pretend running a worker in another site: *)
  let env_of_params_and_exps conf site params =
    (* First the params: *)
    let env =
      Hashtbl.enum params /@
      (fun ((n : N.field), v) ->
        Printf.sprintf2 "%s%s=%a"
          param_envvar_prefix
          (n :> string)
          RamenTypes.print v) |>
      List.of_enum in
    (* Then the experiment variants: *)
    let env =
      RamenExperiments.all_experiments conf.persist_dir |>
      List.fold_left (fun env (name, exp) ->
        (exp_envvar_prefix ^ name ^"="^
          exp.RamenExperiments.variants.(exp.variant).name) :: env
      ) env in
    (* Then the site name: *)
    ("site="^ (site : N.site :> string)) :: env

  let wants_to_run conf site fname params =
    let args = [| (fname : N.path :> string) ; WorkerCommands.wants_to_run |] in
    let env = env_of_params_and_exps conf site params |> Array.of_list in
    Files.with_stdout_from_command
      ~expected_status:0 ~env fname args Legacy.input_line |>
    bool_of_string

  let of_bin =
    let log errors_ok fmt =
      (if errors_ok then !logger.debug else !logger.error) fmt in
    (* Cache of path to date of last read and program *)
    let reread_data (program_name, fname) errors_ok : t =
      !logger.debug "Reading config from %a..." N.path_print fname ;
      match version_of_bin fname with
      | exception e ->
          let err = Printf.sprintf2 "Cannot get version from %a: %s"
                      N.path_print fname (Printexc.to_string e) in
          log errors_ok "%s" err ;
          failwith err
      | v when v <> RamenVersions.codegen ->
        let err = Printf.sprintf2
                    "Executable %a is for version %s (I'm version %s)"
                    N.path_print fname
                    v RamenVersions.codegen in
        log errors_ok "%s" err ;
        failwith err
      | _ ->
          (try info_of_bin program_name fname with e ->
             let err = Printf.sprintf2 "Cannot get info from %a: %s"
                         N.path_print fname
                         (Printexc.to_string e) in
             !logger.error "%s" err ;
             failwith err)
    and age_of_data (_, fname) errors_ok =
      try Files.mtime fname
      with e ->
        log errors_ok "Cannot get mtime of %a: %s"
          N.path_print fname
          (Printexc.to_string e) ;
        0.
    in
    let get_prog = cached2 "of_bin" reread_data age_of_data in
    fun ?(errors_ok=false) program_name params (fname : N.path) ->
      let p = get_prog (program_name, fname) errors_ok in
      (* Patch actual parameters (in a _new_ prog not the cached one!): *)
      { default_params = RamenTuple.overwrite_params p.default_params params ;
        funcs = List.map (fun f -> Func.{ f with program_name }) p.funcs ;
        condition = p.condition ; globals = p.globals }

end
*)

(*
 * Running Config: what programs must run where.
 *
 * Note: keyed by program name. Several distinct instances of the same binary
 * can easily be given different names using `ramen run --as` if that's needed.
 *)
(*
module Running =
struct
  type entry =
    { (* Tells whether the entry must actually be started. Set to true
         at exit so that we do not loose information of previously run
         entries. *)
      mutable status : worker_status [@ppp_default MustRun] ;
      (* Should this worker be started in debug mode regardless of supervisor
       * mode? *)
      debug : bool [@ppp_default false] ;
      (* Stat report period: *)
      report_period : float [@ppp_default Default.report_period] ;
      (* Full path to the worker's binary: *)
      bin : N.path ;
      (* "Command line" for that worker: *)
      params : RamenParams.t [@ppp_default Hashtbl.create 0] ;
      (* Optionally, file from which this worker can be (re)build (see RamenMake).
       * When it is rebuild, relative parents are found using the program name that's
       * the key in the running config. *)
      src_file : N.path [@ppp_default N.path ""] ;
      (* Optionally, run this worker only on these sites: *)
      on_site : Globs.t [@ppp_default Globs.all] ;
      (* For nodes added automatically, that were not in the RC file proper *)
      automatic : bool [@ppp_default false] }

  (* Killed programs are kept in the RC file unless --purged, so it's still
   * possible to get their stats etc. *)
  and worker_status = MustRun | Killed

  (* The rc file keyed by program name: *)
  type running_config = (N.program, entry) Hashtbl.t

  let match_localsite conf site_glob =
    Globs.matches site_glob (conf.site :> string)

  let find_func programs fq =
    let program_name, func_name = N.fq_parse fq in
    let rce, get_rc =
      Hashtbl.find programs program_name in
    let prog = get_rc () in
    rce, prog, List.find (fun f -> f.Func.name = func_name) prog.Program.funcs
end
*)
(*
 * Global per-func stats that are updated by the thread reading #notifs and
 * the one reading the RC, and also saved on disk while ramen is not running:
 *)

module FuncStats =
struct
  type t =
    { startup_time : float ; (* To distinguish from present run *)
      min_etime : float option [@ppp_default None] ;
      max_etime : float option [@ppp_default None] ;
      tuples : int64 [@ppp_default 0L] ;
      bytes : int64 [@ppp_default 0L] ;
      cpu : float (* Cumulated seconds *) [@ppp_default 0.] ;
      ram : int64 (* Max observed heap size *) [@ppp_default 0L] ;
      mutable parents : (N.site * N.fq) list ;
      (* Also gather available history per running workers, to speed up
       * establishing query plans: *)
      mutable archives : TimeRange.t [@ppp_default []] ;
      mutable num_arc_files : int [@ppp_default 0] ;
      mutable num_arc_bytes : int64 [@ppp_default 0L] }

  let make ~startup_time =
    { startup_time ; min_etime = None ; max_etime = None ;
      tuples = 0L ; bytes = 0L ; cpu = 0. ; ram = 0L ; parents = [] ;
      archives = TimeRange.empty ; num_arc_files = 0 ; num_arc_bytes = 0L }

  let archives_print oc =
    List.print (Tuple2.print Float.print Float.print) oc
end
