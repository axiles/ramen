(* Given RamenConstsCliInfo, generate functions that execute subcommands
 * as other processes: *)
open Batteries
open RamenHelpersNoLog

module CliInfo = RamenConstsCliInfo

let make_id s =
  String.map (function
    | '-' -> '_'
    | c -> c
  ) s

let emit_function oc cmd =
  let p fmt = emit oc 0 fmt in
  let fun_name = "run_" ^ cmd.CliInfo.name in
  let print_fun_arg oc opt =
    let opt_id = List.hd opt.CliInfo.names |> make_id in
    Printf.fprintf oc "?%s" opt_id
  in
  p "let %s %a () ="
    fun_name
    (List.print ~first:"" ~last:"" ~sep:" " print_fun_arg) cmd.opts ;
  p "  let cmd = N.path Sys.argv.(0) in" ;
  p "  let args = [] in" ;
  List.iter (fun opt ->
    let opt_name = List.hd opt.CliInfo.names in
    let opt_id = make_id opt_name in
    match opt.typ with
    | CliInfo.Flag ->
        p "  let args = if %s = Some true then \"--%s\" :: args else args in"
          opt_id
          opt_name
    | CliInfo.Scalar ->
        p "  let args = match %s with Some v -> \"--%s\" :: v :: args"
          opt_id opt_name ;
        p "             | None -> args in"
    | CliInfo.List ->
        p "  let args =" ;
        p "    List.fold_left (fun args v ->" ;
        p "      \"--%s\" :: v :: args" opt_name ;
        p "    ) args (%s |? []) in" opt_id
  ) cmd.opts ;
  p "  let args = \"ramen\" :: %S :: args in" cmd.name ;
  p "  let args = Array.of_list args in" ;
  p "  let env = Unix.environment () in" ;
  p "  RamenProcesses.run_background cmd args env" ;
  p ""

let emit_functions oc =
  [ CliInfo.confserver ;
    CliInfo.gc ;
    CliInfo.archivist ;
    CliInfo.precompserver ;
    CliInfo.execompserver ;
    CliInfo.choreographer ;
    CliInfo.supervisor ;
    CliInfo.replayer ;
    CliInfo.alerter ] |>
  List.iter (emit_function oc)

let emit_all oc =
  Printf.fprintf oc "(* Generated by genRamenSubcommands *)\n" ;
  Printf.fprintf oc "open Batteries\n" ;
  Printf.fprintf oc "module N = RamenName\n\n" ;
  emit_functions oc

let () =
  emit_all stdout
